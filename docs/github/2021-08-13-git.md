---
layout: default
title:  "Git 개념 및 Github repo clone"
parent: Github
nav_order: 97
---

컴퓨터 포맷을 한 김에 github을 처음 시작하는 방법도 같이 정리해보려고 한다. 이전 포스팅에서는 git, github이 사용가능하다는 전제 하에 블로그를 시작하는 방법을 정리했다. Github는 버전 관리 시스템 웹호스팅을 맡은 일종의 저장소이자 서비스이며, git은 저장소에 내 resource를 버전 별로 저장, 관리해주는 시스템이다.

## Git이란

![](https://s-seo.github.io/assets/images/post_git_1.png) 
출처: <https://velog.io/@leobit/Git-workflow>

git은 형상 관리 도구(configuration management tool) 중 하나다. 다른 말로 버전 관리 시스템이라고 한다. 소프트웨어 개발에 필요한 소스코드를 효과적으로 관리할 수 있는 무료 공개 소프트웨어다. Open source contribution이 이런 것과 연관된 건가..? 여튼 기존에는 서브버전(SVN)이라는 틀이 있는데 이보다 여러 장점을 갖춘 git으로 많이 넘어온 상태다. 그럼 왜 git이 좋은지?

* 분산형 관리 시스템: 소스코드를 여러 개발 PC와 저장소에 분산해서 저장하기 때문에 한 곳에서 에러가 발생해도 다른 곳의 저장소를 이용해 복원 가능하다. 
* 빠른 속도: 사본을 로컬에서 관리하기 때문에 중앙 서버를 이용하는 SVN에 비해 상대적으로 빠름.
* 병렬 개발: 소스코드를 주고 받을 필요 없이 같은 파일을 여러 명이 동시에 작업할 수 있다. 구체적으로는 브랜치를 나눠(fork) 개발한 뒤, 나중에 merge하는 방식으로 co-developing 할 수 있다.
* 오프라인에서도 버전 관리가 가능하다. 스테이지에 올린다는게 이러한 특징을 만들어내는건가?

그럼 이렇게 버전 관리를 해주는 시스템이란 기술, 프로그램은 잘 알겠는데 이를 실제로 구현시킬 물리적인 공간이 필요하다. 이를 git 웹호스팅 시스템이라고 하며 협업하는 코드를 저장할 수 있고, push, pull request 같은 이벤트에 반응하여 자동으로 작업을 실행해주는 역할을 할 수 있다. 대표적으로 Github이 있으며 GitLab, BitBucket 등이 있다. 관련 용어를 정리해보자.

* `Repository`: 말 그대로 저장소를 의미하며, 모든 히스토리가 담겨져있다.
* `Working Tree`: 특정 시점의 저장소(?)를 의미한다.
* `Staging Area`: 저장소에 커밋하기 전 준비, 점검시키는 공간
* `Commit`: 스테이지에 올라온, 변경된 작업 상태를 저장소에 저장하는 작업
* `Branch`: 어떤 작업이 있다면 현재 작업 상태를 복사하여 저장하는 공간. 브랜치에서 작업 한 후 완전하다 싶을 때 merge한다.
* `Head`: 현재 작업 중인 브랜치를 의미함
* `Merge`: 다른 브랜치의 내용을 현재 브랜치로 가져와 합치는 작업

## Git 설치

[git 설치 사이트](https://git-scm.com)에 들어가 git을 다운받는다. 거의 다 `Next`를 눌러 넘기되, terminal emulator 선택화면에서는 **Use Window's default console window**를 선택한다. 

git을 처음 설치하면 사용할 이름, 이메일을 등록해야 한다. cmd를 실행해서 아래 명령어를 입력하자

```
$ git config --global user.name 사용할이름
$ git config --global user.email 사용할이메일
```



## Git 명령어

`$ git init`: 해당 폴더에 깃을 시작시킴. 해당 디렉토리에 ".git"이란 숨겨진 하위폴더가 생성됨

`$ git status`: 깃의 상태를 출력함. 해당 경로와 관련하여 마스터 브랜치가 존재하는지, 커밋했는지, 커밋할게 있는지. 해당 경로에 만약 깃에서 버전관리하지 않은 파일이 있다면 **Untracked files**라는 리스트로 출력됨. 이전에 커밋했으나 수정한 파일이 있다면 **modified**라고 상태가 나타남.

`$ git add`: 파일을 스테이지로 올린다. 스테이지는 생성, 수정한 파일을 올리는 공간이다. 여기에 파일을 먼저 올려야 저장소로 커밋할 수 있다. 면접 대기실이 있는 것 처럼 파일들 모아서 정렬시키는 역할로 메모리 공간, 시간적으로 효율적인 버전관리가 가능한 것. 이후 다시 `$ git status`를 입력하면 **Changes to be committed**라는 리스트가 출력된다. 개별 파일명을 입력해도 되고, `$git add .`로 모든 파일은 한번에 스테이지로 올릴 수 있다.

`$ git commit -m '메시지'` : 스테이지에 올라온 파일을 저장소로 커밋한다. **n files changed, n insertion**이라는 문구가 출력된다. 이후 `$ git status`를 입력하면 **nothing to commit, working tree clean**이라는 문구가 나와야함.

`$git log`: 커밋한 기록을 확인할 수 있다.

`$git commit -am '메시지'`: git add, commit을 동시에 한다.

`$git diff`: 파일의 수정된 부분을 나타낸다. 즉, 최신 버전의 파일과 수정한 파일의 차이점을 보여주는 것.

* git init으로 깃을 시작한 폴더 내에서 git으로 버전관리하고 싶지 않은 파일들이 있을 수 있다. 이 떄 git init이 적용된 폴더에 **.gitignore** 파일을 만들어 파일목록을 입력하면 된다. **.gitignore** 파일 자체는 버전관리에 포함되지만 파일의 목록에 해당하는 파일들은 버전관리에 포함되지 않게된다.

`$ git restore`: 수정한 파일 되돌리기. ctrl+z와 비슷한 것 같다.

`$ git restore --staged`: 스테이지에 올라간 파일을 취소한다. 

`$ git reset HEAD^^`: 최신 커밋을 취소한다. 커밋이 취소되고 unstaged 되었다는 내용이 출력된다. 여기에 `$ git restore`까지 해주면 파일을 원래 상태로 돌릴 수도 있다.

더 많은 git 명령어는 [git 명령어](https://reddb.tistory.com/147?category=948284)를 참고하면 된다.




## Github blog 로컬 웹페이지 호스팅 및 깃헙 커밋

github.io 레포의 HTTPS 주소를 복사한 뒤, cmd에서 아래 명령어를 입력한다.

```
$ cd 원하는 경로
$ git clone 복사한 주소
```

* 해당 폴더를 열면 내가 github에 커밋시킨 파일이 다 로컬로 복사된 것을 확인할 수 있다. [Ruby를 설치하고, jekyll을 다운받는 것](https://s-seo.github.io/blog/first-post/)은 블로그 재료를 만들기 위함인데 이미 그 재료는 만들어서 github에 업로드했으니 따로 설치할 필요는 없다. (다만 작업의 편리성을 위해선 로컬 웹페이지 호스팅이 필요하고, 이룰 위해선 Ruby와 jekyll이 필요하다... )

* 포맷을 한지 일주일 정도 지났는데, 이제 슬슬 포스트를 본격적으로 쓰다보니 포스트 수정 사항을 깃헙에 바로 푸쉬하는게 번거로워 다시 로컬 웹페이지 호스팅을 돌리려고 시도했다. 근데 이걸로 거의 하루를...! 그것도 면접 전날을 통째로 날려먹었다. 결과적으로 해결법은 **경로를 잘 살펴보는 것**이다. 이 문제를 해결하려고 노력하면서 `jekyll`이나 `bundle`에 대해 배운 것도 있어 정리해본다.

```
$ bundle # 또는 bundle install
```

을 실행하면

> There was an error parsing `Gemfile`: There are no gemspecs at C:/Users/baoro/OneDrive/바탕 화면/Blog/s-seo.github.io. Bundler cannot continue.

이와 같은 에러 메시지가 뜨는데, 이 경우는 `Gemfile`에 `gemspec`을 지운 뒤 `gem "minimal-mistakes-jekyll"`을 추가하면 해결된다. [Minimal-mistakes 공식문서](https://github.com/mmistakes/minimal-mistakes)에는 이후 `$ bundle`을 실행한 뒤 `_config.yml` 파일에 `theme: minimal-mistakes-jekyll`를 추가하면 된다고 나와있다. 보통은 이제 `$ jekyll serve`를 실행하면 `jekyll`이 내장하고 있는 서버를 동작시키고 이를 로컬 PC에서 확인할 수 있다. 이걸 좀 더 업그레이드 시킨 것이 `$ bundle exec jekyll serve`인데 bundler는 Ruby에서 필요한 gem을 관리, 추적할 수 있어 디버깅(?)에 유용한 기능을 가지고 있다. 이 경우 뜨는 에러는

1.`Invalid CP949 character`

이건 윈도우 OS에서 jekyll을 사용할 때 UTF-8 인코딩을 사용한다면 발생할 수 있는 에러다. 일종의 OS와 콘솔창의 호환 문제라고 생각할 수 있는데 cmd에 [`$ chcp 65001`을 입력](https://aisiunme.github.io/jekyll/2018/07/25/troubleshooting-in-jekyll-serve/)하면 cmd 화면이 `Active code page: 65001`로 넘어가면서 `$ jekyll serve`를 실행시킬 수 있다. 또는 한글이 쓰인 파일을 직접 경로를 역추적해서 찾아낸 뒤 수정하는 [방법](https://min9nim.github.io/2018/08/jekyll-sass/)도 있다.


2.`you don't have kramdown-parser-gfm`

이건 Gemfile에 `gem "kramdown-parser-gfm"`을 추가하면 된다. 에러 메시지에도 나와있듯이 해당 gem을 설치하면 해결되는 문제다. 그럼 Gemfile이 아래와 같아질 것이다.

```
source "https://rubygems.org"

gem "minimal-mistakes-jekyll"
gem "kramdown-parser-gfm"
```

3.`Internal Error: Invalid UTF-8`

여튼 위 프로세스를 마치면 로컬 웹페이지를 호스팅할 수 있다는건데, 내 경우에는 

```
$ bundle exec jekyll serve
```

를 실행하면

> Conversion error: Jekyll::Converters::Scss encountered an error while converting 'assets/css/main.scss': Internal Error: Invalid UTF-8


위와 같은 에러가 떴다. `Internal Error: Invalid UTF-8`이라는 에러는 구글링해도 안나와서 머리를 꽁꽁 싸맸는데, 예전에도 이런 스트레스, 짜증을 경험한 적이 떠올랐고 그 때 문제의 원인은 폴더 경로에 한글이 들어가 있었다는 점이 생각났다. 이번에 포맷하면서 시작하자맞 자동적으로 Onedrive를 사용하게 됐는데 경로에도 Onedrive가 들어갔고, Onedrive에서 사용하는 Desktop은 `바탕화면`이라는 한글로 경로에 포함되어 있었다. 이 점이 문제가 되어 듣도보도 못한 에러를 발생시킨 것이다. 그래서 `바탕화면`-`속성`-`위치`에 들어가서 경로를 `기본값 복원`으로 되돌렸고, 이 때 리디렉션이 이뤄지면서 기존 파일을 새로운 경로에 복사시킨다. 시간 좀 걸리는데, 막상 복사가 다 안돼도 어차피 Onedrive 경로는 남아있으니 다시 돌아가서 복사해주면 된다. 처음엔 파일 날라간 줄 알고 진짜 울뻔했다ㅠㅠ 마지막으로 확실하게 하기 위해 `제어판`-`프로그램 제거`에서 `Microsoft Onedrive`를 제거해주면 된다. 

이제 다시 cmd에서 바뀐 경로로 들어가 `$ bundle exec jekyll serve`를 실행하면 로컬 웹페이지이 호스팅되는 것을 확인할 수 있다. 정말 너무 허무하지만 열심히 노력한 시간이었다.. 내 하루ㅠ


* 포스트를 새로 만들거나 수정한게 있으면 아래 명령어를 입력하는 작업이면 github blog 관리에 충분하다.

```
$ git add 파일명 또는 .
$ git commit -m '메시지'
$ git push -u origin master
```















